# 연결 리스트
연결리스트란?
- 물리적으로 흩어져 있는 자료들을 서로 연결하여 하나로 묶어 관리하는 데이터 구조이다.
- 노드 간의 연결을 이용해 리스트를 구현한 것이다.

## 구조
연결 리스트는 노드들의 집합으로 데이터를 저장하고 있고 서로 연결 되어 있다. 실제로 일렬로 연결되어있다기 보단, 하나의 노드에 다음 노드 주소가 들어있는 느낌이다.
일반적인 노드는 데이터 필드와 링크 필드로 구성되어 있다. 데이터 필드에는 데이터가 들어가고 다양한 자료형이 올 수 있다. 링크 필드에는 다음 노드의 주소를 저장한다.

연결리스트에서는 첫번쨰 노드의 주소가 중요한데, 이 노드의 주소를 저장하는 노드를 Head라고 한다.
연결 리스트의 마지막은 마지막 노드의 링크 필드를 NULL 값으로 하여 표현하고 이를 Tail 이라고도 한다.

## 종류
### 1. 단순 연결 리스트 (Singly Linked List)
- 하나의 방향으로만 연결되어 있으며 맨 마지막 노드의 링크 필드는 NULL 값을 가진다.
### 2. 원형 연결 리스트 (Circular Linked List)
- 단순 연결 리스트와 같지만 맨 마지막 노드의 링크 값이 다시 첫번째 노드를 가리킨다.
### 3. 이중 연결 리스트 (Doubly Linked List)
- 각 노드마다 링크 필드가 2개씩 존재하며 각각 선행 노드(previous node)와 후행 노드(next node)를 가리킨다.

## 시간 복잡도
데이터 검색 시 논리적 저장 순서와 물리적 저장 순서가 다르기 때문에 처음 노드부터 순회해야 한다. 메모리 공가나 상에서 각 노드들이 연속적으로 이루어져 있지 않고 흩어져 있고, 각각의 노드가 자신의 다음 노드 위치를 알고 있는 형태이다.
각 노드들이 메모리 공간 상의 어디에 위치하는지는 각각의 노드들만 알고 있고, 사용자는 제일 첫 번째 노드의 위치만 알고 있다. 그래서 그 원소를 찾거나 삽입하거나 삭제하기 위해선 O(n) 시간이 발생한다.
### 접근
- O(n) : get,set 접근하고자 하는 위치까지 해드노드부터 찾아가야함.

### 삽입
- O(1) : push , unshift
- O(n) : insert

### 제거
- O(1) : shift
- O(n) : pop, remove 삭제하려는 위치까지 접근해서 삭제해야함.

### 탐색
- O(n) : 탐색하고자 하는 위치까지 찾아가야함.


## 배열(array)과 리스트(list) 비교
### 요약
<table>
<tr>
<th scope="col"> </td>
<th scope="col">배열</td>
<th scope="col">리스트</td>
</tr>
<tr>
    <td>메모리 공간</td>
    <td>크기</td>
    <td>삽입</td>
    <td>삭제</td>
    <td>탐색</td>
    <td>구현</td>
</tr>
<tr>
    <td>연속O</td>
    <td>최소 선언 시 크기로 고정되며 사용되지 않은 공간도 함께 할당해야 해서 비효율적이다.</td>
    <td>중간에 데이터를 삽입하기 어렵다. 추가하려는 위치 이후의 모든 자료들을 전부 하나씩 뒤로 미는 작업이 필요하다. (O(n))</td>
    <td>중간에 데이터를 삭제하기 어렵다. 삭제후 남은 데이터들의 위치를 다시 옮겨줘야한다. (O(n))</td>
    <td>인덱스를 사용해서 빠르게 탐색 가능하다(O(1))</td>
    <td>간단</td>
</tr>
<tr>
    <td>연속X</td>
    <td>고정되지 않으며 필요할때마다 추가가능하다. 공간활용이 효율적이다.</td>
    <td>중간에 삽입하기 용이하다. 연결된 링크만 수정하면 된다. (O(1))</td>
    <td>중간에 데이터를 삭제하기 쉽다. 삭제하려는 노드만 제거하고 앞,뒤 링크만 연결하면 된다. (O(1))</td>
    <td>무조건 Head 부터 순차적으로 노드를 순회해야하기 때문에 효율적이기 못하다. (O(n))</td>
    <td>어려움</td>
</tr>
</table>

### 구체적인 비교

***Array***
- 배열이며, 논리적 저장순서와 물리적 저장순서가 일치한다.
- 특정 자료형들이 메모리 공간 상에서 연속적으로 이루어져 있다.
- immutable 하다.
- 인덱스로 해당 원소에 접근할 수 있으며, 인덱스를 알고 있다면 O(1)의 시간 복잡도로 원소에 접근이 가능하다. 즉, Random Access가 가능하다.
  - O(1)
- 삭제 또는 삽입 과정에서는 해당 원소에 접근하여 작업을 완료한 뒤, shift 해줘야 하므로 비용이 발생한다.
  - O(n)
- 메모리 공간 활용에 제약이 있다.

***Dynamic Array(ArrayList)***
- 이름처럼 내부적으로 배열을 사용하여 데이터를 관리한다.
- 인덱스를 가지고 있어 데이터 검색에 적합하고 속도가 빠르다.
  - 시간 복잡도 : O(1)
- 데이터의 삽입, 삭제 시 해당 데이터를 제외한 모든 데이터를 임시 배열을 생성해 복사하므로 삽입, 삭제가 빈번할 경우 속도가 느리며 부적합하다.
  - 시간 복잡도 : O(n)
- 동기화를 지원하지 않아 Vector 보다 빠르다.


***LinkedList***
- 데이터 검색 시 처음 노드부터 순회해야 한다. 이유는 논리적 저장 순서와 물리적 저장 순서가 다르기 때문이다.
  - O(n)
- 메모리 공간 상에서 각 노드들이 연속적으로 이루어져 있지 않고 흩어져 있으며, 각각의 노드가 자신의 다음 노드의 위치를 알고 있는 형태이다.
- 각 노드들이 메모리 공간 상의 어디에 위치하는지는 각각의 노드들만 알고 있고, 사용자는 제일 첫 번째 노드의 위치만 알고 있는 상태이다.
- 어떤 원소를 삽입, 삭제 시 그 원소를 찾기 위해 O(n)의 시간이 발생하고 추가적으로 작업을 완료하는 시간까지 O(n)의 시간이 걸린다.
- 결국, LinkedList 는 검색과 삽입, 삭제 과정 모두 O(n)의 시간 복잡도를 갖는다.


## 참고자료
https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data%20Structure/%5BData%20Structure%5D%20Array%20vs%20LinkedList.md
https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data%20Structure/%5BData%20Sturcture%5D%20ArrayList%20vs%20LinkedList.md

## 구현과정에서 생긴 고민
